<script>
  var collectionFetcherBehavior = {
    start: function () {
      this.started = true;
      this.refresh();
    },

    stop: function () {
      this.started = false;
      this.reset();
    },

    refresh: function () {
      this.reset();
      var url = this._getCurrentPageUrl(this.cursor);
      if (!!url && this.started) {
        this.fetchPage(url);
      }
    },

    getColumns: function () {
      return []
    },

    getElementStruct: function () {
      return this.$$('[role = doc]').doc[0]['response-data'];
    },

    reset: function () {
      var client = this.$$('[role=client]');
      if (!!client) {
        this.fetcher = client;
      }
      else {
        log.warn('collection fetcher client not found in dom');
      }
      this.isReady = false;

      this.collectionStatus = 'free';
      this.results = [];
      this.continuousResults = [];
      this.cache = {};
      this.cursor = {};
      this.status = {};
      this.lastIndex = 0;
    },

    fetchNext: function () {
      this.fetchPage(this._getNextPageUrl(this.cursor));
    },
    fetchPrv: function () {
      this.fetchPage(this._getPrevPageUrl(this.cursor));
    },


    fetchPage: function (pageUrl) {
      if (!!pageUrl && !(!!this.status[pageUrl])) {
        this.collectionStatus = 'busy';
        this.status[pageUrl] = 'pending';
        console.log('fetching: ' + pageUrl);
        this.fetchingUrl = pageUrl;
        this.fetcher.fetch(pageUrl)
          .then(function (res) {
            this._onData(pageUrl, res)
          }.bind(this))
          .catch(function (err) {
            var errObj = this._parseError(err);
            if (this._checkError(pageUrl, errObj)) {
              this._onResults()
            } else {
              this._onError(pageUrl, errObj);
            }
          }.bind(this));
      }
    },

    _onData: function (url, data) {
      this.status  [url] = 'cached';
      this.cache   [url] = data;
      this.cursor = this._getCursor(data);

      var index = this._getPageIndex(this.cursor);
      var result = this._getResult(data);
      this.isReady = true;
      this.results = result;
      if (index === (this.lastIndex + 1)) {
        this.continuousResults = this.continuousResults.concat(result);
      }
      this.lastIndex = index;
      this._onResults(this.results, this.continuousResults);
      this.collectionStatus = 'free';
    },

    _checkError: function (url, error) {
      if (error.code === 404) {
        this.collectionStatus = this._getPageIndex(url) === 1 ? 'empty' : 'completed';
          if (this.collectionStatus === 'empty') {
              this.results = [];
              this.continuousResults = [];
          }
        return true;
      } else {
        this.collectionStatus = 'free';
        return false;
      }
    },

    _onError: function (url, error) {
      delete this.status[url];
    },

    _onEmpty: function () {
    },
    _parseError: function (error) {
      console.log(error.message);
      try {
        return JSON.parse(error.message)
      } catch (e) {
        return {message: error.message, code: 100}
      }
    },
    _getCursor: function (response) {
    },
    _getResult: function (response) {
    },
    _getCurrentPageUrl: function (cursor) {
    },
    _getNextPageUrl: function (cursor) {
    },
    _getPrevPageUrl: function (cursor) {
    },

    _getPageIndex: function (cursor) {
      return 0
    },
    _onResults: function () {
      this.fire('results', {results: this.results, continuousResults: this.continuousResults})
    },

    _onCollectionStatusChange: function (status) {
      this.fire('collection-status-change', this.collectionStatus);
    },

    properties: {
      fetcher: Object,
      firstUrl: String,
      status: Object,
      cache: Object,
      cursor: Object,
      lastIndex: Number,

      collectionStatus: {type: String, value: 'free', notify: true, observer: '_onCollectionStatusChange'},
      started: {type: Boolean, value: false, notify: true},
      isReady: {type: Boolean, value: false, notify: true},

      results: {type: Object, notify: true},
      continuousResults: {type: Array, notify: true}
    }
  }
</script>
